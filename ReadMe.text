클래스, 객체, 인스턴스
클래스는 설계도이고, 이설계도를 기반으로 실제 메모리에 만들어진(new 로 생성) 실체를 객체또는 인스턴스라고한다. 둘다 같은 의미로 사용

int , long, double, boolean 등등은 원시타입형 이라 소문자로 시작
String 은 클래스라 앞에 대문자로 시작한다
자바에서는 클래스는 앞에 대문자를 사용한다.

new 로 사용해서 객체를 생성하게되면 자동으로 초기화를 해준다.
int = 0, boolean = false, 참조형 = null

***** 자바에서는 아무도 참조하지않는 인스턴스가있으면 JVM 의 GC가 더이상 사용하지않는 인스턴스라고 판단하고 자동으로 메모리에서 삭제해준다.

정리
대원칙: 자바는 항상 변수의 값을 복사해서 대입한다.
기본형이면 변수에 들어있는 실제값을 복사해서 대입하고
참조형이면 변수에 들어있는 참조값을 복사해서 대입한다.

- 기본형 vs 참조형 (기본)
    - 자바의 데이터 타입을 가장 크게 보면 기본형과 참조형으로 나눌수있다.
    - 기본형을 제외한 나머지 변수는 모두 참조형이다. 클래스와 배열을 다루는 변수는, 참조형이다.
    - 기본형 변수는 값을 직접 저장하지만, 참조형 변수는 참조(주소)를 저장한다.
    - 기본형 변수는 산술연산을 수행할수있지만, 참조형 변수는 산술연산을 수행할수없다.
    - 기본형 변수는 null 을 할당할수없지만, 참조형 변수는 null 을 할당할수있다.

기본형 vs 참조형 (대입)
    - 기본형과 참조형 모두 대입시 변수 안에 있는 값을 읽고 복사해서 전달한다.
    - 기본형은 사용하는 값을 복사해서 전달하고, 참조형은 참조값을 복사해서 전달한다. (실제 인스턴스가 복사되는게아닌 인스턴스를 가리키는 참조값을 복사해서 전달)

기본형 vs 참조형 (메소드 호출)
    - 메서드 호출시 기본형은 메서드 내부에서 파라미터의 값을 변경해도 호출자의 변수 값에는 영향이없다.
    - 메서드 호출시 참조형은 메서드 내부에서 파라미터로 전달된 객체의 맴버 변수를 변경하면 호출자의 객체도 변경된다.


절차지향 프로그래밍 vs 객체지향 프로그래밍
- 둘의 차이는 절차지향은 데이터와 해당 데이터에 대한 처리방식이 분리되어있다 반면에 객체지향에서는 데이터와 그 데이터에 대한 행동(메서드)이 하나의 객체안에 포함되어있다.
- 객체지향 프로그래밍과 절차지향 프로그래밍은 서로 대치되는 개념이아니다. 객체지향이라도 프로그램의 작동순서는 중요하다 다만 어디에 더 초점을 맞추는가에 둘의 차이가있다.
  객체지향의 경우 객체의 설계와 관계를 중시한다. 반면 절차 지향의 경우 데이터와 기능이 분리되어있고 프로그램이 어떻게 작동되는지 그순서에 초점을맞춘다.

- 절차지향 프로그래밍
    - 실행순서를 중요하게 생각하는 방식.
    - 프로그램의 흐름을 순차적으로 따르며 처리하는방식. 즉 어떻게? 를 중심으로 프로그래밍한다.

- 객체지향 프로그래밍
    - 객체를 중요하게 생각하는 방식.
    - 실제 세계의 사건이나 사물을 객체로보고, 이러한 객체들간의 상호작용을 중심으로 프로그래밍하는방식, 즉 무엇을? 중심으로 프로그래밍한다.



MusicPlayer 클래스를 보면 음악플레이어를 구성하기위한 속성과 기능이 하나의 캡슐에 쌓여있는것 같다 이렇게 속성과 기능을 하나로 묶어서 필요한 기능을 메서드를 통해 외부에 제공하는걸 캡슐화라고한다


-생성자
    - new 키워드를 사용해서 객체를 생성할때 마지막에 괄호() 도 포함해야 하는 이유가 바로 생성자 때문이다 객체를 생성하면서 동시에 생성자를 호출한다는 의미를 포함하고있다.

기본생성자
    - 매개변수가 없는 생성자를 기본생성자라고한다.
    - 클래스에 생성자가 하나도 없으면 자바 컴파일러는 매개변수가 없고 작동하는 코드가없는 기본 생성자를 자동으로 만들어준다.
    - 생성자가 하나라도 있으면 자바는 기본생성자를 만들지 않는다.
    - 생성자는 반드시 호출되어야한다.


- this() 라는 기능을 사용하면 생성자 내부에서 자신의 생성자를 호출할수있다. 참고로 this 는 인스턴스 자신의 참조값을 가리킨다 그래서 자신의 생성자를 호출한다고 생각하면된다
    - this()는 생성자 내부에서만 사용가능
    - this()는 생성자 코드의 첫줄에만 작성할수있다.


패키지
    - 다른패키지의 같은이름의 클래스가있다면 둘중하나만 임포트가 가능하다 나머지하나는 어쩔수없이 풀네임을 써주어야한다.

    - 패키지 규칙
        - 패캐지의 이름과 위치는 폴더(디렉토리)위치와 같아야한다 *필수
        - 패키지 이름은 모두 소문자를 사용한다 (관례)
        - 패키지 이름의 앞 부분에는 일반적으로 희사의 도메인 이름을 거꾸로 사용한다 ex) com.company.myapp  (관례)

    - 패키지와 계층구조
        - 패캐지는 사람들이 보기좋게 계층구조로 표현될뿐 전혀다른 패키지이다 서로연관이없다 그래서 다른패키지를 사용하려면 임포트해야한다


접근제어자
    - private : 모든 외부 호출을 막는다 ( 클래스에서만 호출가능 )
    - default (package-private) : 같은 패키지안에서 호출은 허용한다.
    - protected : 같은 패키지안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
    - public : 모든 외부 호출을 허용한다.

    접근제어자사용-클래스레벨
    - 규칙
        - 클래스 레벨의 접근 제어자는 public, default 만 사용할수있다.
        - public 클래스는 반드시 파일명과 이름이 같아야한다.
            - 하나의 자바파일에 public 클래스는 하나만 등장할수있다.
            - 하나의 자바파알에 default 접근제어자를 사용하는 클래스는 무한정 만들수있다.

자바 메모리 구조
    * 비유 *
-   자바가 실행되면 JVM 내부에 이러한 메모리 구조를 가지고 동작한다.
    - 메서드 영역 : 클래스 정보를 보관, 클래스정보가 붕어빵 틀이다.
    - 스택 영역 : 실제 프로그램이 실행되는 영역, 메서디를 실행할때마다 하나씩 쌓인다.
    - 힙 영역 : 객체(인스턴스)가 생성되는 영역, new 명령어를 사용하면 이영역을 사용, 쉽게 이야기하면 붕어빵틀로부터 생성된 붕어빵이 존재하는공간, 배열도 이영역에 생성


    * 실제 *
    - 메서드 영역 : 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리한다, 이 영역은 프로그램의 모든 영역에서 공유한다.
        - 클래스정보 : 클래스의 실행코드(바이트코드), 필드, 메서드와 생성자 코드 등 모든 실행 코드가 존재한다.
        - static 영역 : static 변수들을 보관한다.
        - 런타임 상수 풀 : 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다. 예를들어 프로그램에
                        "hello" 라는 리터럴 문자가있으면 이런문자를 공통으로 묶어서 관리한다, 이외에도 프로그램들을 효율적으로 관리하기위한 상수들을 관리한다.

    - 스택 영역 : 자바 실행시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역변수, 중간연산결과, 메서드 호출 정보등을 포함한다
        - 스택 프레임 : 스택 영역에 쌓이는 네모박스 하나가 스택프레임이다. 메서드를 호출할때마다 하나의 스택프레임이 쌓이고, 메서드가 종료되면 해당 스택프레임이 제거된다.

    - 힙 영역 : 객체(인스턴스)와 배열이 생성되는 영역, 가비지컬렉션이 이루어지는 주요 영역이며 더이상 참조되지않는 객체는 GC에 의해 제거된다.

    ** 참고 : 스택 영역은 더 정확히는 각 쓰레드별로 하나의 실행 스텍이 생성된다. 따라서 쓰레드 수만큼 스택 영역이 생성된다.
             지금은 쓰레드를 1개만 사용하므로 스택영역도 하나이다. 쓰레드에 대한 부분은 멀티쓰레드를 학습해야 이해할수있다.

    *** 자바에서 특정클래스로 100개의 인스턴스를 생성하면 힙메모리에 100 개의 인스턴스가 생긴다. 각각의 인스턴스는 내부에 변수와 메서드를 가진다.
        같은 클래스로부터 생성된 객체라도 인스턴스 내부의 변수값은 서로 다를수있지만 메서드는 공통된 코드를 공유한다
        따라서 객체가 생성될때 인스턴스 변수는 메모리에 할당되지만, 메서드에 대한 새로운 메모리 할당은없다 메서드는 메서드영역에서 공통으로 관리되고 실행한다.
        -> 객체의 변수값은 다를수있어 힙메모리에 생성되지만 메서드는 똑같으므로 메서드영역에서 관리하며 메서드 영역에 있는 코드를 불러서 실행한다.

스택과 큐 자료 구조
    스택(Stack) : 후입선출(LIFO)
    큐(Queue) : 선입선출(FIFO)


- 스태틱이 붙은 맴버변수는 메서드 영역에서 관리한다.

변수와 생명주기
    - 지역변수 (매개변수포함) : 지역변수는 스택 영역에 있는 스택프레임안에 보관된다. 메서드가 종료되면 스택 프레임도 제거되는데 이때 해당 스택 프레임에 포함된
                           지역변수도 함께 제거된다. 따라서 지역변수는 생존주기가 짧다.

    - 인스턴스 변수 : 인스턴스에 있는 맴버 변수를 인스턴스 변수라 한다. 인스턴스 변수는 힙영역을 사용한다. 힙영역은 GC 가 발생하기전까지 생존한다

    - 클래스변수 : 클래스 변수는 메서드 영역의 static 영역에 보관되는 변수이다. 메서드 영역은 프로그램 전체에서 사용하는 공용공간이다 클래스 변수는 해당 클래스가
                JVM 에 로딩되는 순간 생성된다 그리고 JVM 이 종료될때까지 생명주기가 이어진다.

    ** static 이 정적이라는 이유는 여기에있다 힙영역에 생성되는 인스턴스 변수는 동적으로 생성되고, 제거된다. 반면에 static 정적변수는
        프로그램 실행시점에 생성되고 프로그램 종료시점에 제거된다


  **정적메서드는 클래스이름을 통해 바로 호출할수있다. 그래서 인스턴스처럼 참조개념이없다.
    특정 인스턴스 기능을 사용하려면 참조값을 알아야하는데 정적메소드는 참조값 없이 호출한다.
    따라서 정적 메서드 내부에서 인스턴스 변수나 인스턴스 메서드를 사용할수없다.


상수 : 상수는 변하지않고 항상일정한 값을 갖는 수를 말한다.
    특징
        - static final 키워드를 사용한다.
        - 대문자를 사용하고 구분은 _(언더스코어)로 한다. (관례)
            - 일반적인 변수와 상수를 구분하기 위해 이렇게 한다.
        - 필드를 직접 접근해서 사용한다.
            - 상수는 기능이 아니라 고정된 값 자체를 사용하는 것이 목적이다.
            - 상수는 값을 변경할수없다, 따라서 필드에 직접 접근해도 데이터가 변하는 문제가 발생하지않는다.


****** 상속과 메모리 구조
    - 상속관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
    - 상속관계의 객체를 호출할때 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
    - 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지못하면 컴파일 오류가 발생한다.


메서드 오버라이딩 조건
    - 메서드이름 이 같아야한다.
    - 메서드 매개변수 타입, 순서, 개수가 같아야한다.
    - 반환타입이 같아야한다. 단 반환타입이 하위 클래스 타입일수있다.
    - 접근제어자 는 상위 클래스의 메서드보다 더 제한적이어서는 안된다.
    - 더많은 예외 또는 상위타입의 예외는 선언할수없다.
    - static, final, private 키워드가 붙은 메서드는 오버라이딩 될수 없다.
        - static 은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미없다. static 은 그냥 클래스 이름을 통해 접근하면된다.
        - final 은 최초 한번 할당후 재정의를 금지하므로 재정의가불가.
        - private 메서드는 해당 클래스에서만 접근이가능하므로 하위에는 보이지않는다 따라서 재정의를 할수없다.
    - 생성자 오버라이딩은 할수없다.

- 오버라이딩 어노테이션
    - @Overriding 어노테이션은 생략이가능( 부모메소드와 형태가같으면 오버라이딩된것으로 판단) 하지만 명시적으로 써주는게좋다
        - 실수를줄이려고 ( 부모클래스에 메소드가없으면 에러를 표시 )
        - 누가봐도 메소드오버라이딩인걸 알수있다.

상속관계를 사용하면 자식 클래스의 생성자에서는 부모 클래스의 생성자를 반드시 호출해야한다.
    - 기본생성자는 자바에서 자동으로 생성해줘서 생략이가능하다 ( 임으로 생성자를 만들경우 자바에서는 기본생성자를 만들어주지않는다 *55번라인*)
        - 부모클래스의 생성자가 기본 생성자인경우 super() 를 생략할수있다.
            - 상속관계에서 첫줄에 super() 를 생략하면 자바는 부모의 기본 생성자를 호출하는 super() 를 자동으로 만들어준다.
            - 참고로 기본생성자를 많이 사용하기때문에 편의상 이런 기능을 제공한다.
    - 예외로 생성자 첫줄에 super 대신 this 를 사용할수도있지만 super 는 자식의 생성자안에서 언젠가는 반드시 호출되어야한다.


다형성 *****
 - 자바에서 부모는 자식을 담을수있다.
    -> 내가이해한바로는 상속을받은상태에서 new Child() 하게되면 메모리상에    -xx01-------------
                                                               | Parent          |
                                                               | Child           |
                                                               -------------------
       각각 존재하게된다 메모리상에 있으므로 성립이된다
 - Parent poly 는 부모타입이다 new Child() 를 통해 생성된 결과는 Child 타입이다 자바에서 부모타입은 자식 타입을 담을수 있다.
 - 반대로 자식타입은 부모타입을 담을수없다.



 컴파일오류 vs 런타임오류
 - 컴파일오류는 변수명 오타, 잘못된 클래스 이름 사용등 자바 프로그램을 실행하기 전에 발생하는 오류이다. 이런 오류는 IDE 에서 즉시확인할수있기 때문에 안전하고 좋은 오류이다.
 - 런타임오류는 이름그대로 프로그램이 실행되고 있는 시점에 발생하는 오류이다. 런타임 오류는 매우 안좋은 오류이다 왜냐하면 고객이 해당프로그램을 사용하는 도중에 발생하기때문이다.

 Class File OverridngMain
 // poly 는 new Child 로 생성을해서 메모리상에 Parent 와 Child 를 가진다
 // 타입이 Parent 로 지정을해서 Parent 부터 찾는다
 // Parent 의 value 를찾고 method 를 실행하려하지만 하위타입에 Child 에 오버라이딩이 되어있어 하위타입의 method 가 실행된다
 // 필드는 오버라이딩되지않는다
 // ** 오버라이딩된 메서드는 항상 우선권을 가진다 ***


다형성을 이루는 핵심
    - 다형적 참조 : 하나의 변수타입으로 다향한 자식 인스턴스를 참조 할수있는 기능
    - 메서드 오버라이딩 : 기존 기능을 하위 타입에서 새로운 기능으로 재정의


poly -> ex1
 - 처럼 다형적참조와 메소드 오버라이딩을 이용하면 소스중복을 최대로 줄이며 신규동물이 추가되어도 간단하게 추가할수있다
 - 하지만 2가지 문제점이있다
    - 오버라이딩용도로 지정한 Animal 클래스의 sound 메소드 를 재정의하지않을때,
    - 다형성을위해 타입을 맞추려고 만든 껍데기 클래스 Animal 을 직접적으로 생성할수있기때문이다
 이러한 문제점을 해결하기위해 추상클래스와 추상메서드 가 존재한다.

추상클래스
    - 동물과 같이 부모 클래스를 제공하지만 실제생성 되면 안되는 클래스를 추상클래스라고한다.
    - 이름 그대로 추상적인 개념을 제공하는 클래스이다. 따라서 실체인 인스턴스가 존재하지않는다 대신에 상속목적으로 사용되고 부모클래스 역할을 담당한다.

추상메서드
    - 부모클래스를 상속 받는 자식클래스가 반드시 오버라이딩 해야되는 메서드를 부모클래스에 정의할수있다. 이것을 추상메서드라고한다 이름그대로 추상적인 개념을 제공하는메서드다
      따라서 실체가 존재하지 않고, 메서드 바디가없다.

- 추상메서드가 하나라도있으면 추상클래스로 선언해야한다
- 추상메서드 상속 받는 자식 클래스가 반드시 오버라이딩해서 사용해야한다.
- 정리
    - 추상 클래스 덕분에 실수로 인스턴스를 생성할 문제를 근본적으로 방지해준다.
    - 추상 메서드 덕분에 새로운 동물의 자식 클래스를 만들때 실수로 sound() 오버라이딩하지않을 문제를 근본적으로 해결해준다.


순수 추상 클래스 : 모든 메서드가 추상메서드 일경우
    - 인스턴스를 생성할수없다
    - 상속시 자식은 모든 메서드를 오버라이딩 해야한다
    - 주로 다형성을위해 사용된다

-> 사실 자바에는 순수추상클래스라는 용어가없다 하지만 이러한 추상클래스를 더쉽게 이용하기위해 인터페이스라는 개념이 존재한다.

인터페이스는 앞서 설명한 순수추상클래스와 같다. 여기에 약간의 편의기능이 추가된다.
    - 인터페이스이 메서드는 모두 public, abstract 이다.
    - 메서드에 public abstract 를 생략할수 있다. ( 생략권장 )
    - 인터페이스는 다중 구현 (다중상속)을 지원한다.
    - 인터페이스에서 맴버변수는 public, static, final 이 모두 포함되었다고 간주된다. final 은 변수의 값을 한번 설정하면 수정할수없다는뜻이다.

  인터페이스는 추상클래스보다 제약이 더심하다 (반드시 모든메서드를 구현해야한다)


클래스, 추상클래스, 인터페이스는 모두 똑같다.
    - 클래스, 추상클래스, 인터페이스는 프로그램코드, 메모리구조상 모두 똑같다. 모두 자바에서는 .class로 다루어진다 인터페이스를 작성할때도 .java에 인터페이스를 정의한다.
    - 인터페이스는 순수 추상클래스와 비슷하다고 생각하면된다.


다중구현
    - 상속은 단일상속만지원하지만 인터페이스는 다중상속이 가능하다 그이유는뭘까?
        - 상속을 여러군대에서 받으면 Airplane 클래스에 move() 라는 메서드와 Car 클래스에 move() 라는메서드가 존재할경우 어떤 클래스에서 move() 메서드를 호출해야할지 모른다
          하지만 인터페이스는 모든추상메서드로 이루어진 추상클래스이다 그러므로 어떤 클래스의 move() 이건 상관없다 어차피 하위타입에서 재정이 해야하기때문이다.